---
title: "HDD Data Download from SQL Server"
author: "Yao"
date: "May 23, 2018"
output: html_document
---

Updated on 07/18/2018.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(feather)
options(scipen = 999)
```

## Load Database from SQL Server

```{r ConnectDB}
library(DBI)
db = dbConnect(odbc::odbc(),
               driver = 'SQL Server',
               server = 'IRISAGL01.aus.amer.dell.com',
               user = 'Yao_Z',
               password = 'y67uhgt$Y')
```

It is not well known that you can run SQL code in an R Notebook code chunk. To use SQL, open an R Notebook in the RStudio IDE under the File > New File menu. Start a new code chunk with {sql}, and specify your connection with the connection=con code chunk option. If you want to send the query output to an R dataframe use output.var = "mydataframe" in the code chunk options. When you specify output.var you will be able to use the output in subsequent R code chunks. In this example, we use the output in ggplot.

```{sql hdd_qty, connection=db, output.var = 'hdd_qty'}
SELECT 
  D.Cfg_Desc AS CFG, D.sku_num, D.Sample_DPN, C.Fiscal_Qtr, C.Fiscal_Mo, C.Fiscal_Wk, C.Fiscal_Wk_End_Date, C.Fiscal_Date, C.Fiscal_Yr, B.Order_Date_week, C.Fiscal_Mo_End_Date,  C.Fiscal_Qtr_End_Date,
  CASE WHEN A.LOB_DESC = 'PowerEdge' AND A.ESI_order_flag = 'Y' THEN 'PowerEdge - ESI'
                     WHEN A.MGMT_PROD_LVL_3_NM = 'Storage' AND A.DELL_EMC_ORDER_FLAG = 'DELL' THEN 'Storage - DELL'
                ELSE A.LOB_DESC END AS LOB_DESC, A.BRAND_CATG_DESC, 
  A.RGN_DESC,
  A.GBL_PARNT_ACCT_NM AS Customer, 
  SUM(SYS_QTY_DELL) AS SYS_QTY,
  SUM(ITM_QTY) AS PART_QTY
FROM IRIS.[Base].[ISG_Business_Transformation.isgOrders] AS A 
JOIN IRIS.[Base].[ISG_Business_Transformation.isgOrdersDetails] B
ON A.ORD_NBR = B.ORD_NBR AND A.FMLY_PFOLIO_DESC = B.FMLY_PFOLIO_DESC AND A.SRC_BU_ID = B.SRC_BU_ID
JOIN IRIS.DIM.Date C
ON B.ORD_DT = C.Fiscal_Date
JOIN IRIS_Data_Mart.[dbo].[SKU_CFG_Bridge] D
ON B.ITM_NBR = D.sku_num
WHERE D.Cfg_Desc LIKE '%HDD%' AND Commodity_Desc IN ('Hard Drive', 'Controller Cards/HBA') AND A.DELL_EMC_ORDER_FLAG = 'DELL' AND (A.LOB_DESC IN ('PowerEdge','Cloud Products') OR A.MGMT_PROD_LVL_3_NM = 'Storage') ---AND C.Fiscal_Yr >= 'FY16'
GROUP BY
  D.Cfg_Desc, D.sku_num, D.Sample_DPN, C.Fiscal_Qtr, C.Fiscal_Mo, C.Fiscal_Wk, C.Fiscal_Wk_End_Date, C.Fiscal_Date, C.Fiscal_Yr, B.Order_Date_week, C.Fiscal_Mo_End_Date,  C.Fiscal_Qtr_End_Date,
  CASE WHEN A.LOB_DESC = 'PowerEdge' AND A.ESI_order_flag = 'Y' THEN 'PowerEdge - ESI'
                   WHEN A.MGMT_PROD_LVL_3_NM = 'Storage' AND A.DELL_EMC_ORDER_FLAG = 'DELL' THEN 'Storage - DELL'
                   ELSE A.LOB_DESC END, A.BRAND_CATG_DESC, 
  A.RGN_DESC, A.GBL_PARNT_ACCT_NM
ORDER BY D.Cfg_Desc, C.Fiscal_Qtr, C.Fiscal_Mo, C.Fiscal_Wk
```


```{r Deal with missing data}
Weekly_HDD_QTY_combined <- hdd_qty %>% group_by(Order_Date_week,Fiscal_Wk) %>% summarise(Fiscal_Wk_QTY=sum(PART_QTY))

apply(hdd_qty, 2, function(x) any(is.na(x)))

# Columns have NA: Customer
hdd_qty = hdd_qty %>% 
  mutate(Customer = ifelse(
    grepl('Dummy|disti|\032|APPOINTED|ACCT-R', Customer, ignore.case = T) | Customer == '' | is.na(Customer),
    'Unknown_Customer', Customer
  ))

apply(hdd_qty, 2, function(x) any(is.na(x)))
# All NAs have been cleaned.

write_feather(hdd_qty,'~/Yao_Rdata/HDD_QTY_IRIS.feather')
```


```{sql connection=db, output.var = 'mrp_data0'}
SELECT [VERSION], MONWKYR, CFG, REGION, SUM(DATA) AS MRP_CT, Commodity_Desc
FROM IRIS.Base.MRP_Weekly A
JOIN IRIS.DIM.DPN B 
ON A.PART = B.DPN
WHERE B.CFG LIKE '%HDD%' AND B.Commodity_Desc IN ('Hard Drive')--Verified with other restrictions. Good for now.
GROUP BY [VERSION], MONWKYR, CFG, REGION, Commodity_Desc
```

```{r}
#write_feather(mrp_data0,'~/Yao_Rdata/mrp_HDD.feather')
mrp_data0 <- read_feather('~/Yao_Rdata/mrp_HDD.feather')

mrp_data <- mrp_data0
# Extract Month,Week,Year from MONWKYR in the MRP data
mrp_data$MON <- substr(mrp_data$MONWKYR, start = 1, stop = 3)
mrp_data$WK <- substr(mrp_data$MONWKYR, start = 5, stop = 5)
mrp_data$FISC_YR <- substr(mrp_data$MONWKYR, start = 6, stop = 7)

# Order them in the right time order
mrp_data$YRMON <- paste(mrp_data$FISC_YR,mrp_data$MON)
mrp_data %>% 
  mutate(VERSION = factor(VERSION, levels = c("FY19Q2W5","FY19Q2W6","FY19Q2W7","FY19Q2W8","FY19Q2W9","FY19Q2W10"))) %>%
  #mutate(MON = factor(MON, levels = c('JUN','JUL','AUG','SEP','OCT','NOV','DEC','JAN','FEB','MAR','APR','MAY'))) %>%
  mutate(YRMON = factor(YRMON, levels = c('19 JUN','19 JUL','19 AUG','19 SEP','19 OCT','19 NOV','19 DEC','19 JAN','20 FEB','20 MAR','20 APR','20 MAY','20 JUN'))) %>%
  arrange(VERSION,CFG,REGION,YRMON,WK) -> mrp_data.ordered
```

```{sql connection=db, output.var = 'calr2Fisc_match'}
SELECT [CLDR_YYYYMMDD_VAL]
      ,[CLDR_WEEK_VAL]
      ,[CLDR_MTH_VAL]
      ,[CLDR_QTR_VAL]
      ,[FISC_WEEK_VAL]
      ,[FISC_WEEK_END_DATE]
      ,[FISC_MTH_VAL]
      ,[FISC_QTR_VAL]
      ,[FISC_YR_VAL]
	  ,[CLDR_MTH_WEEK_NUM]
	  ,[FISC_MTH_WEEK_NUM]
  FROM [IRIS].[Base].[COMN_BASE.CORP_CLDR]
  WHERE FISC_YR_NUM>=2019 AND FISC_YR_NUM<=2020
```

```{r Map using FISC_YR, CLDR_MTH, FISC_MTH_WEEK_NUM}
#write_feather(calr2Fisc_match,'~/Yao_Rdata/calr2Fisc_match.feather')
calr2Fisc_match <- read_feather('~/Yao_Rdata/calr2Fisc_match.feather')

# Preprocessing the CALR2FISC data to match calender to fiscal year
calr2Fisc_match$FISC_YR <- substr(calr2Fisc_match$FISC_YR_VAL,start = 3,stop = 4) # Use the FISCAL Year to merge
# Extract the Fiscal Week Number and use this to 

Time.needed <- select(calr2Fisc_match,FISC_YR,CLDR_MTH_VAL,FISC_WEEK_VAL,FISC_WEEK_END_DATE,FISC_MTH_WEEK_NUM) %>% unique() %>%
  mutate(CLDR_MTH_VAL = factor(CLDR_MTH_VAL, levels = c('JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'))) %>%
  arrange(FISC_WEEK_VAL,CLDR_MTH_VAL)

# Since some calr months correspond to multiple fiscal month, only keep the correct match, which is the first month that matches the fiscal month. Thus, remove the duplicated rows as needed
# Time.needed$duplicatedCalrMon <- duplicated(Time.needed$CLDR_MTH_VAL)
# Time.needed$duplicatedFiscMon <- duplicated(Time.needed$FISC_MTH_VAL)

mrp_data.ordered$WK <- as.numeric(mrp_data.ordered$WK)

mrp_data.ordered %>% left_join(Time.needed,by = c('FISC_YR','MON'='CLDR_MTH_VAL','WK'='FISC_MTH_WEEK_NUM')) %>% unique() -> mrp_data.wFiscal # FISC_WEEK_END_DATE,
mrp_data.wFiscal[!duplicated(mrp_data.wFiscal$MRP_CT),] -> marp_data.unique
```

Okay. Now all is clear. The MONWKYR in MRP data are actually Calendar Month, Fiscal Week, and Fiscal Year.
7/19/2018 Oh no. Still duplicated data...

```{r Map using FISC_YR, CLDR_MTH, CLDR_MTH_WEEK_NUM}
#write_feather(calr2Fisc_match,'~/Yao_Rdata/calr2Fisc_match.feather')
calr2Fisc_match <- read_feather('~/Yao_Rdata/calr2Fisc_match.feather')

# Preprocessing the CALR2FISC data to match calender to fiscal year
calr2Fisc_match$FISC_YR <- substr(calr2Fisc_match$FISC_YR_VAL,start = 3,stop = 4) # Use the FISCAL Year to merge

Time.needed <- select(calr2Fisc_match,FISC_YR,CLDR_MTH_VAL,FISC_WEEK_VAL,FISC_WEEK_END_DATE,CLDR_MTH_WEEK_NUM) %>% unique() %>%
  mutate(CLDR_MTH_VAL = factor(CLDR_MTH_VAL, levels = c('JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'))) %>%
  arrange(FISC_WEEK_VAL,CLDR_MTH_VAL)

# Since some calr months correspond to multiple fiscal month, only keep the correct match, which is the first month that matches the fiscal month. Thus, remove the duplicated rows as needed
# Time.needed$duplicatedCalrMon <- duplicated(Time.needed$CLDR_MTH_VAL)
# Time.needed$duplicatedFiscMon <- duplicated(Time.needed$FISC_MTH_VAL)

mrp_data.ordered$WK <- as.numeric(mrp_data.ordered$WK)

mrp_data.ordered %>% left_join(Time.needed,by = c('FISC_YR','MON'='CLDR_MTH_VAL','WK'='CLDR_MTH_WEEK_NUM')) %>% unique() -> mrp_data.wFiscal # FISC_WEEK_END_DATE,

mrp_data.wFiscal[!duplicated(mrp_data.wFiscal$MRP_CT),] -> marp_data.unique
```

OMG, the above mapping does not work perfectly.
Let me try another table.


